<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#000000">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Study App</title>
  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="icon-192.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
  <style>
    @font-face {
      font-family: 'Yu Gothic';
      src: local('Yu Gothic Medium'), local('YuGothic-Medium');
    }
    
    :root {
      --bg-primary: #0d0d0d;
      --bg-secondary: #1a1a1a;
      --bg-tertiary: #252525;
      --bg-card: #1e1e1e;
      --text-primary: #f0f0f0;
      --text-secondary: #a0a0a0;
      --text-muted: #666666;
      --accent: #4a9eff;
      --accent-hover: #6bb3ff;
      --success: #4ade80;
      --error: #f87171;
      --warning: #fbbf24;
      --border: #333333;
      --shadow: rgba(0, 0, 0, 0.5);
      --radius: 12px;
      --radius-sm: 8px;
      --transition: 0.2s ease;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }

    input, textarea, select,
    input[type="text"], input[type="date"], input[type="time"], input[type="number"] {
      user-select: text;
      -webkit-user-select: text;
      -webkit-touch-callout: default;
    }

    body {
      font-family: 'Roboto', 'Yu Gothic', 'YuGothic', sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      line-height: 1.5;
      -webkit-tap-highlight-color: transparent;
    }

    /* ============ LAYOUT ============ */
    .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      padding-bottom: 100px;
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 20px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .header h1 {
      font-size: 1.25rem;
      font-weight: 500;
    }

    .header-back {
      background: none;
      border: none;
      color: var(--accent);
      font-size: 1rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .header-actions {
      display: flex;
      gap: 12px;
    }

    /* ============ NAVIGATION ============ */
    .nav {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--bg-secondary);
      border-top: 1px solid var(--border);
      display: flex;
      justify-content: space-around;
      padding: 12px 0;
      z-index: 100;
    }

    .nav-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 8px 16px;
      transition: var(--transition);
    }

    .nav-item.active {
      color: var(--accent);
    }

    .nav-item svg {
      width: 24px;
      height: 24px;
    }

    .nav-item span {
      font-size: 0.75rem;
    }

    /* ============ BUTTONS ============ */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 12px 24px;
      border-radius: var(--radius);
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: var(--transition);
      border: none;
      font-family: inherit;
    }

    .btn-primary {
      background: var(--accent);
      color: #000;
    }

    .btn-primary:hover {
      background: var(--accent-hover);
    }

    .btn-secondary {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border: 1px solid var(--border);
    }

    .btn-secondary:hover {
      background: var(--bg-card);
    }

    .btn-danger {
      background: var(--error);
      color: #000;
    }

    .btn-icon {
      padding: 8px;
      background: var(--bg-tertiary);
      border-radius: var(--radius-sm);
    }

    .btn-icon svg {
      width: 20px;
      height: 20px;
    }

    /* ============ CARDS & LISTS ============ */
    .card {
      background: var(--bg-card);
      border-radius: var(--radius);
      padding: 16px;
      border: 1px solid var(--border);
      transition: var(--transition);
    }

    .card:hover {
      border-color: var(--text-muted);
    }

    .card-clickable {
      cursor: pointer;
    }

    .list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .list-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px;
      background: var(--bg-card);
      border-radius: var(--radius);
      border: 1px solid var(--border);
      cursor: pointer;
      transition: var(--transition);
    }

    .list-item:hover {
      border-color: var(--accent);
    }

    .list-item-content {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .list-item-icon {
      width: 40px;
      height: 40px;
      background: var(--bg-tertiary);
      border-radius: var(--radius-sm);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .list-item-icon svg {
      width: 20px;
      height: 20px;
      color: var(--accent);
    }

    .list-item-text h3 {
      font-size: 1rem;
      font-weight: 500;
      margin-bottom: 2px;
    }

    .list-item-text h3 u,
    .list-item-text p u {
      text-decoration: underline;
    }

    .list-item-text h3 strong,
    .list-item-text p strong {
      font-weight: 700;
    }

    .list-item-text h3 em,
    .list-item-text p em {
      font-style: italic;
    }

    .list-item-text p {
      font-size: 0.875rem;
      color: var(--text-secondary);
    }

    .list-item-arrow {
      color: var(--text-muted);
    }

    /* ============ FEATURED DECKS ============ */
    .featured-section {
      margin-bottom: 32px;
    }

    .featured-title {
      font-size: 0.875rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 12px;
    }

    .featured-decks {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
    }

    .featured-deck {
      background: linear-gradient(135deg, var(--bg-tertiary), var(--bg-card));
      border-radius: var(--radius);
      padding: 16px;
      border: 1px solid var(--border);
      cursor: pointer;
      transition: var(--transition);
    }

    .featured-deck:hover {
      border-color: var(--accent);
      transform: translateY(-2px);
    }

    .featured-deck h3 {
      font-size: 0.875rem;
      font-weight: 500;
      margin-bottom: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .featured-deck p {
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    .featured-deck .due-date {
      font-size: 0.7rem;
      color: var(--warning);
      margin-top: 8px;
    }

    /* ============ FORMS ============ */
    .form-group {
      margin-bottom: 20px;
    }

    .form-label {
      display: block;
      font-size: 0.875rem;
      color: var(--text-secondary);
      margin-bottom: 8px;
    }

    .form-input {
      width: 100%;
      padding: 12px 16px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      color: var(--text-primary);
      font-size: 1rem;
      font-family: inherit;
      transition: var(--transition);
    }

    .form-input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .form-input::placeholder {
      color: var(--text-muted);
    }

    /* ============ FLASHCARD STUDY ============ */
    .study-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: calc(100vh - 160px);
      padding: 20px;
    }

    .study-progress {
      width: 100%;
      max-width: 500px;
      margin-bottom: 24px;
    }

    .progress-bar {
      height: 4px;
      background: var(--bg-tertiary);
      border-radius: 2px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: var(--accent);
      transition: width 0.3s ease;
    }

    .progress-text {
      display: flex;
      justify-content: space-between;
      margin-top: 8px;
      font-size: 0.875rem;
      color: var(--text-secondary);
    }

    .flashcard {
      width: 100%;
      max-width: 500px;
      aspect-ratio: 3/2;
      perspective: 1000px;
      cursor: pointer;
    }

    .flashcard-inner {
      width: 100%;
      height: 100%;
      position: relative;
      transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      transform-style: preserve-3d;
    }

    .flashcard-inner.flipped {
      transform: rotateY(180deg);
    }

    .flashcard-face {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 24px;
      background: var(--bg-card);
      border-radius: var(--radius);
      border: 2px solid var(--border);
      text-align: center;
      overflow: auto;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }

    .flashcard-back {
      transform: rotateY(180deg);
    }

    .flashcard-face h2 {
      font-size: 1.5rem;
      font-weight: 400;
      word-break: break-word;
    }

    .flashcard-face h2 u {
      text-decoration: underline;
    }

    .flashcard-face h2 strong {
      font-weight: 700;
    }

    .flashcard-face h2 em {
      font-style: italic;
    }

    .flashcard-face img {
      max-width: 100%;
      max-height: 60%;
      object-fit: contain;
      margin-top: 12px;
      border-radius: var(--radius-sm);
    }

    .flashcard-label {
      position: absolute;
      top: 12px;
      left: 12px;
      font-size: 0.75rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .study-actions {
      display: flex;
      justify-content: center;
      margin-top: 24px;
    }

    .study-btn {
      width: 52px;
      height: 52px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: var(--transition);
      border: none;
    }

    .study-btn svg {
      width: 22px;
      height: 22px;
    }

    .study-btn.back {
      background: rgba(160, 160, 160, 0.15);
      color: var(--text-secondary);
    }

    .study-btn.back:hover {
      background: rgba(160, 160, 160, 0.25);
    }

    .study-btn.back:disabled {
      opacity: 0.2;
      cursor: not-allowed;
    }

    /* ============ SWIPE ANIMATION ============ */
    .flashcard-wrapper {
      position: relative;
      width: 100%;
      max-width: 500px;
    }

    .flashcard {
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      will-change: transform;
      transition: none;
    }

    .flashcard.swiping {
      transition: none;
    }

    .flashcard.animate-out {
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
    }

    .flashcard.animate-enter {
      animation: cardEnter 0.2s cubic-bezier(0.2, 0, 0.2, 1) forwards;
    }

    @keyframes cardEnter {
      0% {
        opacity: 0;
        transform: scale(0.95) translateY(12px);
      }
      100% {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }

    .swipe-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: var(--radius);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.1s ease;
      pointer-events: none;
      z-index: 10;
    }

    .swipe-overlay-correct {
      background: rgba(74, 222, 128, 0.15);
      border: 3px solid var(--success);
      border-radius: var(--radius);
    }

    .swipe-overlay-wrong {
      background: rgba(248, 113, 113, 0.15);
      border: 3px solid var(--error);
      border-radius: var(--radius);
    }

    .study-container.no-scroll {
      overflow: hidden;
      touch-action: none;
    }

    body.studying {
      overflow: hidden;
    }

    .study-options {
      display: flex;
      gap: 12px;
      margin-bottom: 24px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .toggle-btn {
      padding: 8px 16px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 20px;
      color: var(--text-secondary);
      font-size: 0.875rem;
      cursor: pointer;
      transition: var(--transition);
    }

    .toggle-btn.active {
      background: var(--accent);
      color: #000;
      border-color: var(--accent);
    }

    /* ============ TODO LIST (Google Tasks style) ============ */
    .todo-list {
      padding: 0;
    }

    .todo-item {
      display: flex;
      align-items: flex-start;
      gap: 14px;
      padding: 14px 4px;
      border-bottom: 1px solid var(--border);
      margin-bottom: 0;
      background: none;
      border-radius: 0;
    }

    .todo-item:last-child {
      border-bottom: none;
    }

    .todo-checkbox {
      width: 22px;
      height: 22px;
      border: 2px solid var(--text-muted);
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.2s ease;
      flex-shrink: 0;
      margin-top: 1px;
      position: relative;
    }

    .todo-checkbox:hover {
      border-color: var(--accent);
      background: rgba(74, 158, 255, 0.1);
    }

    .todo-checkbox:active {
      transform: scale(0.9);
    }

    .todo-checkbox.checked {
      background: var(--accent);
      border-color: var(--accent);
    }

    .todo-checkbox.checked::after {
      content: '';
      position: absolute;
      top: 3px;
      left: 6px;
      width: 5px;
      height: 9px;
      border: solid #000;
      border-width: 0 2px 2px 0;
      transform: rotate(45deg);
    }

    .todo-content {
      flex: 1;
      min-width: 0;
    }

    .todo-title {
      font-size: 0.975rem;
      font-weight: 400;
      color: var(--text-primary);
      line-height: 1.4;
    }

    .todo-description {
      font-size: 0.8rem;
      color: var(--text-secondary);
      margin-top: 2px;
      line-height: 1.35;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .todo-details {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
      margin-top: 6px;
    }

    .todo-detail-chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 0.72rem;
      color: var(--text-secondary);
      line-height: 1;
    }

    .todo-detail-chip svg {
      width: 12px;
      height: 12px;
      flex-shrink: 0;
    }

    .todo-detail-chip.overdue {
      color: var(--error);
    }

    /* Priority badges */
    .priority-badge {
      display: inline-flex;
      align-items: center;
      padding: 2px 7px;
      border-radius: 4px;
      font-size: 0.65rem;
      font-weight: 600;
      letter-spacing: 0.3px;
      text-transform: uppercase;
    }

    .priority-badge.summative {
      background: rgba(248, 113, 113, 0.2);
      color: #f87171;
    }

    .priority-badge.formative {
      background: rgba(251, 191, 36, 0.2);
      color: #fbbf24;
    }

    .priority-badge.task {
      background: rgba(74, 158, 255, 0.15);
      color: #4a9eff;
    }

    .priority-badge.low {
      background: rgba(160, 160, 160, 0.15);
      color: #888;
    }

    .todo-decks {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 6px;
    }

    .todo-deck-link {
      padding: 3px 9px;
      background: var(--bg-tertiary);
      border-radius: 12px;
      font-size: 0.68rem;
      color: var(--accent);
      cursor: pointer;
      transition: var(--transition);
      border: none;
      font-family: inherit;
    }

    .todo-deck-link:hover {
      background: var(--accent);
      color: #000;
    }

    .todo-delete-btn {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 6px;
      border-radius: 50%;
      transition: var(--transition);
      flex-shrink: 0;
      opacity: 0.4;
    }

    .todo-delete-btn:hover {
      opacity: 1;
      background: rgba(248, 113, 113, 0.1);
      color: var(--error);
    }

    .todo-delete-btn svg {
      width: 16px;
      height: 16px;
    }

    /* Completed section */
    .completed-section {
      margin-top: 24px;
      border-top: 1px solid var(--border);
      padding-top: 12px;
    }

    .completed-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 4px;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
    }

    .completed-header svg {
      width: 18px;
      height: 18px;
      color: var(--text-muted);
      transition: transform 0.2s ease;
    }

    .completed-header.expanded svg {
      transform: rotate(90deg);
    }

    .completed-header span {
      font-size: 0.85rem;
      color: var(--text-secondary);
      font-weight: 500;
    }

    .completed-list {
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    .completed-list .todo-item {
      opacity: 0.5;
    }

    .completed-list .todo-title {
      text-decoration: line-through;
      color: var(--text-secondary);
    }

    /* FAB for adding todos */
    .fab {
      position: fixed;
      bottom: 84px;
      right: 20px;
      width: 56px;
      height: 56px;
      border-radius: 16px;
      background: var(--accent);
      color: #000;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(74, 158, 255, 0.3);
      transition: all 0.2s ease;
      z-index: 90;
    }

    .fab:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 20px rgba(74, 158, 255, 0.4);
    }

    .fab:active {
      transform: scale(0.95);
    }

    .fab svg {
      width: 24px;
      height: 24px;
    }

    /* Priority selector chips */
    .priority-options {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .priority-option {
      padding: 8px 14px;
      border-radius: 20px;
      border: 1px solid var(--border);
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      font-size: 0.8rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      font-family: inherit;
    }

    .priority-option:active {
      transform: scale(0.95);
    }

    .priority-option.selected {
      border-color: transparent;
    }

    .priority-option.selected[data-priority="summative"] {
      background: rgba(248, 113, 113, 0.2);
      color: #f87171;
      border-color: rgba(248, 113, 113, 0.4);
    }

    .priority-option.selected[data-priority="formative"] {
      background: rgba(251, 191, 36, 0.2);
      color: #fbbf24;
      border-color: rgba(251, 191, 36, 0.4);
    }

    .priority-option.selected[data-priority="task"] {
      background: rgba(74, 158, 255, 0.15);
      color: #4a9eff;
      border-color: rgba(74, 158, 255, 0.3);
    }

    .priority-option.selected[data-priority="low"] {
      background: rgba(160, 160, 160, 0.15);
      color: #999;
      border-color: rgba(160, 160, 160, 0.3);
    }

    /* Time scroll picker */
    .time-picker-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .scroll-picker {
      flex: 1;
      height: 120px;
      overflow-y: auto;
      scroll-snap-type: y mandatory;
      -webkit-overflow-scrolling: touch;
      border-radius: var(--radius-sm);
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      position: relative;
    }

    .scroll-picker::before,
    .scroll-picker::after {
      content: '';
      position: sticky;
      display: block;
      height: 40px;
      z-index: 2;
      pointer-events: none;
    }

    .scroll-picker::before {
      top: 0;
      background: linear-gradient(to bottom, var(--bg-tertiary), transparent);
    }

    .scroll-picker::after {
      bottom: 0;
      background: linear-gradient(to top, var(--bg-tertiary), transparent);
    }

    .scroll-picker-item {
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      scroll-snap-align: center;
      font-size: 1rem;
      color: var(--text-secondary);
      cursor: pointer;
      transition: color 0.15s, font-size 0.15s;
    }

    .scroll-picker-item.selected {
      color: var(--text-primary);
      font-size: 1.15rem;
      font-weight: 500;
    }

    .scroll-picker-highlight {
      position: absolute;
      top: 50%;
      left: 4px;
      right: 4px;
      height: 40px;
      transform: translateY(-50%);
      border-radius: 6px;
      background: rgba(74, 158, 255, 0.1);
      border: 1px solid rgba(74, 158, 255, 0.2);
      pointer-events: none;
      z-index: 1;
    }

    .time-picker-separator {
      font-size: 1.2rem;
      font-weight: 700;
      color: var(--text-secondary);
    }

    /* Deck picker (folder navigation) */
    .deck-picker {
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      background: var(--bg-tertiary);
      max-height: 240px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    .deck-picker-breadcrumb {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 10px 12px;
      font-size: 0.75rem;
      color: var(--text-muted);
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 0;
      background: var(--bg-tertiary);
      z-index: 1;
    }

    .deck-picker-breadcrumb button {
      background: none;
      border: none;
      color: var(--accent);
      cursor: pointer;
      font-size: 0.75rem;
      font-family: inherit;
      padding: 0;
    }

    .deck-picker-breadcrumb span {
      color: var(--text-muted);
    }

    .deck-picker-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      cursor: pointer;
      transition: background 0.15s;
      border-bottom: 1px solid rgba(51,51,51,0.5);
    }

    .deck-picker-item:last-child {
      border-bottom: none;
    }

    .deck-picker-item:active {
      background: rgba(74, 158, 255, 0.08);
    }

    .deck-picker-item svg {
      width: 18px;
      height: 18px;
      flex-shrink: 0;
      color: var(--text-muted);
    }

    .deck-picker-item.is-folder svg {
      color: var(--warning);
    }

    .deck-picker-item .dp-name {
      flex: 1;
      font-size: 0.85rem;
      color: var(--text-primary);
    }

    .deck-picker-item .dp-meta {
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    .deck-picker-item .dp-arrow {
      color: var(--text-muted);
      font-size: 0.8rem;
    }

    .deck-picker-item .dp-check {
      width: 20px;
      height: 20px;
      border: 2px solid var(--border);
      border-radius: 4px;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
    }

    .deck-picker-item .dp-check.checked {
      background: var(--accent);
      border-color: var(--accent);
    }

    .deck-picker-item .dp-check.checked::after {
      content: '';
      width: 5px;
      height: 9px;
      border: solid #000;
      border-width: 0 2px 2px 0;
      transform: rotate(45deg);
      margin-top: -2px;
    }

    .selected-decks-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 8px;
    }

    .selected-deck-chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      background: rgba(74, 158, 255, 0.12);
      border: 1px solid rgba(74, 158, 255, 0.25);
      border-radius: 14px;
      font-size: 0.72rem;
      color: var(--accent);
    }

    .selected-deck-chip button {
      background: none;
      border: none;
      color: var(--accent);
      cursor: pointer;
      font-size: 0.85rem;
      padding: 0;
      line-height: 1;
      font-family: inherit;
    }

    .selected-deck-chip button:hover {
      color: var(--error);
    }

    /* ============ MODALS ============ */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: 20px;
    }

    .modal {
      background: var(--bg-secondary);
      border-radius: var(--radius);
      width: 100%;
      max-width: 500px;
      max-height: 90vh;
      overflow-y: auto;
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 20px;
      border-bottom: 1px solid var(--border);
    }

    .modal-header h2 {
      font-size: 1.25rem;
      font-weight: 500;
    }

    .modal-close {
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 4px;
    }

    .modal-body {
      padding: 20px;
    }

    .modal-footer {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      padding: 20px;
      border-top: 1px solid var(--border);
    }

    /* ============ STUDY COMPLETE ============ */
    .study-complete {
      text-align: center;
      padding: 40px 20px;
    }

    .study-complete h2 {
      font-size: 1.5rem;
      margin-bottom: 16px;
    }

    .study-stats {
      display: flex;
      justify-content: center;
      gap: 32px;
      margin: 24px 0;
    }

    .stat {
      text-align: center;
    }

    .stat-value {
      font-size: 2rem;
      font-weight: 700;
    }

    .stat-value.correct {
      color: var(--success);
    }

    .stat-value.wrong {
      color: var(--error);
    }

    .stat-label {
      font-size: 0.875rem;
      color: var(--text-secondary);
    }

    .study-complete-actions {
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-width: 300px;
      margin: 0 auto;
    }

    /* ============ LOADING & SYNC ============ */
    .sync-indicator {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 8px 16px;
      background: var(--bg-secondary);
      border-radius: 20px;
      font-size: 0.875rem;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 8px;
      z-index: 200;
      border: 1px solid var(--border);
    }

    .sync-indicator.syncing {
      color: var(--accent);
    }

    .sync-indicator.error {
      color: var(--error);
    }

    .spinner {
      width: 16px;
      height: 16px;
      border: 2px solid currentColor;
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .loading-screen {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      gap: 16px;
    }

    .loading-screen .spinner {
      width: 40px;
      height: 40px;
      border-width: 3px;
      color: var(--accent);
    }

    /* ============ EMPTY STATES ============ */
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: var(--text-secondary);
    }

    .empty-state svg {
      width: 64px;
      height: 64px;
      margin-bottom: 16px;
      opacity: 0.5;
    }

    .empty-state h3 {
      font-size: 1.125rem;
      margin-bottom: 8px;
      color: var(--text-primary);
    }

    /* ============ SWIPE HINTS ============ */
    .swipe-hint {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      font-size: 0.75rem;
      color: var(--text-muted);
      pointer-events: none;
    }

    .swipe-hint.left {
      left: -60px;
    }

    .swipe-hint.right {
      right: -60px;
    }

    /* ============ RESPONSIVE ============ */
    @media (max-width: 600px) {
      .featured-decks {
        grid-template-columns: 1fr;
      }

      .flashcard {
        aspect-ratio: 4/3;
      }

      .study-btn {
        width: 44px;
        height: 44px;
      }

      .study-btn svg {
        width: 18px;
        height: 18px;
      }

      .swipe-hint {
        display: none;
      }
    }

    /* ============ HIDDEN ============ */
    .hidden {
      display: none !important;
    }

    /* ============ EDGE SWIPE BACK ============ */
    .edge-swipe-indicator {
      position: fixed;
      top: 0;
      left: 0;
      width: 40px;
      height: 100%;
      z-index: 999;
      pointer-events: none;
    }

    .edge-swipe-arrow {
      position: fixed;
      left: -30px;
      top: 50%;
      transform: translateY(-50%);
      width: 30px;
      height: 30px;
      background: var(--accent);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.15s ease, left 0.15s ease;
      z-index: 1000;
      pointer-events: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }

    .edge-swipe-arrow svg {
      width: 16px;
      height: 16px;
      color: #000;
    }

    .page-transition {
      animation: slideIn 0.25s cubic-bezier(0.2, 0, 0.2, 1);
    }

    @keyframes slideIn {
      from { opacity: 0; transform: translateX(-30px); }
      to { opacity: 1; transform: translateX(0); }
    }

    /* ============ SECTION HEADER ============ */
    .section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }

    .section-title {
      font-size: 0.875rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* ============ REMINDER CHIPS ============ */
    .reminder-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 12px;
    }

    .reminder-chip {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      background: var(--bg-tertiary);
      border-radius: 12px;
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    .reminder-chip button {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 0;
      line-height: 1;
      font-size: 0.75rem;
    }

    .reminder-chip button:hover {
      color: var(--error);
    }

    .reminder-chip button:first-of-type:hover {
      color: var(--accent);
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- Loading Screen -->
    <div id="loading-screen" class="loading-screen">
      <div class="spinner"></div>
      <p>Loading...</p>
    </div>
  </div>

  <!-- Sync Indicator -->
  <div id="sync-indicator" class="sync-indicator hidden">
    <div class="spinner"></div>
    <span>Syncing...</span>
  </div>

  <!-- Edge Swipe Back Indicator -->
  <div class="edge-swipe-arrow" id="edge-swipe-arrow">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
      <polyline points="15 18 9 12 15 6"/>
    </svg>
  </div>

  <!-- Bottom Navigation -->
  <nav class="nav">
    <button class="nav-item active" data-view="flashcards">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="2" y="4" width="20" height="16" rx="2"/>
        <line x1="2" y1="10" x2="22" y2="10"/>
      </svg>
      <span>Flashcards</span>
    </button>
    <button class="nav-item" data-view="todos">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M9 11l3 3L22 4"/>
        <path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11"/>
      </svg>
      <span>Tasks</span>
    </button>
  </nav>

  <script>
    // ============ CONFIGURATION ============
    const APPS_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbweV3aDJpY4Mf0TZQdeeOFZK_7Taq6oYmaDLmA5guaSPKR3SyP_ehwdG4tfWykr9nTV_g/exec';

    // ============ STATE ============
    let state = {
      folders: [],
      decks: [],
      cards: [],
      todos: [],
      currentView: 'flashcards',
      currentFolder: null,
      currentDeck: null,
      editingCard: null,
      editingParentFolder: null,
      studySession: null,
      showCompleted: false,
      settings: {
        shuffle: true,
        reverse: false
      }
    };

    // ============ LOCAL STORAGE ============
    function saveToLocal() {
      localStorage.setItem('studyAppData', JSON.stringify({
        folders: state.folders,
        decks: state.decks,
        cards: state.cards,
        todos: state.todos,
        settings: state.settings
      }));
    }

    function loadFromLocal() {
      const data = localStorage.getItem('studyAppData');
      if (data) {
        const parsed = JSON.parse(data);
        state.folders = parsed.folders || [];
        state.decks = parsed.decks || [];
        state.cards = parsed.cards || [];
        state.todos = parsed.todos || [];
        state.settings = parsed.settings || { shuffle: true, reverse: false };
        return true;
      }
      return false;
    }

    // ============ API ============
    async function apiCall(action, params = {}) {
      const url = new URL(APPS_SCRIPT_URL);
      url.searchParams.set('action', action);
      Object.entries(params).forEach(([k, v]) => {
        url.searchParams.set(k, typeof v === 'object' ? JSON.stringify(v) : v);
      });

      try {
        const response = await fetch(url.toString());
        return await response.json();
      } catch (error) {
        console.error('API Error:', error);
        throw error;
      }
    }

    async function syncData() {
      showSyncIndicator(true);
      try {
        const data = await apiCall('syncAll');
        state.folders = data.folders || [];
        state.decks = data.decks || [];
        state.cards = data.cards || [];
        state.todos = data.todos || [];
        saveToLocal();
        showSyncIndicator(false);
        return true;
      } catch (error) {
        showSyncIndicator(false, true);
        return false;
      }
    }

    function showSyncIndicator(show, error = false) {
      const indicator = document.getElementById('sync-indicator');
      if (show) {
        indicator.classList.remove('hidden', 'error');
        indicator.classList.add('syncing');
        indicator.innerHTML = '<div class="spinner"></div><span>Syncing...</span>';
      } else if (error) {
        indicator.classList.remove('hidden', 'syncing');
        indicator.classList.add('error');
        indicator.innerHTML = '<span>Sync failed</span>';
        setTimeout(() => indicator.classList.add('hidden'), 3000);
      } else {
        indicator.classList.add('hidden');
      }
    }

    // ============ NOTIFICATIONS ============
    async function requestNotificationPermission() {
      if ('Notification' in window && Notification.permission === 'default') {
        await Notification.requestPermission();
      }
    }

    function scheduleReminders() {
      if (!('Notification' in window) || Notification.permission !== 'granted') return;

      state.todos.forEach(todo => {
        if (!todo.reminders || todo.completed) return;
        
        todo.reminders.forEach(reminderDateTime => {
          const reminderTime = new Date(reminderDateTime).getTime();
          const now = Date.now();
          const delay = reminderTime - now;

          if (delay > 0 && delay < 86400000 * 14) { // Within 14 days
            setTimeout(() => {
              new Notification('Study Reminder', {
                body: todo.title,
                icon: 'icon-192.png',
                tag: todo.id + reminderDateTime,
                silent: true
              });
            }, delay);
          }
        });
      });
    }

    // ============ SPACED REPETITION ============
    function getWeightedCards(cards, shuffle = true) {
      // Cards with higher wrongCount appear more frequently
      const weighted = [];
      cards.forEach(card => {
        const weight = Math.max(1, (card.wrongCount || 0) * 2 + 1);
        for (let i = 0; i < weight; i++) {
          weighted.push({ ...card });
        }
      });

      if (shuffle) {
        for (let i = weighted.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [weighted[i], weighted[j]] = [weighted[j], weighted[i]];
        }
      }

      // Remove duplicates while keeping weighted order
      const seen = new Set();
      return weighted.filter(card => {
        if (seen.has(card.id)) return false;
        seen.add(card.id);
        return true;
      });
    }

    // ============ RENDER FUNCTIONS ============
    function render() {
      const app = document.getElementById('app');
      
      // Toggle body class for study view (disable scrolling)
      if (state.currentView === 'study') {
        document.body.classList.add('studying');
      } else {
        document.body.classList.remove('studying');
      }
      
      switch (state.currentView) {
        case 'flashcards':
          app.innerHTML = renderFlashcardsView();
          break;
        case 'todos':
          app.innerHTML = renderTodosView();
          break;
        case 'folder':
          app.innerHTML = renderFolderView();
          break;
        case 'study':
          app.innerHTML = renderStudyView();
          break;
        case 'study-setup':
          app.innerHTML = renderStudySetupView();
          break;
        case 'add-todo':
          app.innerHTML = renderAddTodoView();
          setTimeout(initTimePickers, 50);
          break;
        case 'add-folder':
          app.innerHTML = renderAddFolderView();
          break;
        case 'add-deck':
          app.innerHTML = renderAddDeckView();
          break;
        case 'deck-detail':
          app.innerHTML = renderDeckDetailView();
          break;
        case 'add-card':
          app.innerHTML = renderAddCardView();
          break;
        case 'edit-card':
          app.innerHTML = renderEditCardView();
          break;
      }

      attachEventListeners();
    }

    function renderFlashcardsView() {
      const upcomingDecks = getUpcomingDecks();
      const rootFolders = state.folders
        .filter(f => !f.parentPath)
        .sort((a, b) => (a.order || 999) - (b.order || 999));

      return `
        <div class="header">
          <h1>Flashcards</h1>
          <div class="header-actions">
            <button class="btn-icon" onclick="syncData().then(render)">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M23 4v6h-6M1 20v-6h6"/>
                <path d="M3.51 9a9 9 0 0114.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0020.49 15"/>
              </svg>
            </button>
          </div>
        </div>
        <div class="container">
          ${upcomingDecks.length > 0 ? `
            <div class="featured-section">
              <h2 class="featured-title">Study Soon</h2>
              <div class="featured-decks">
                ${upcomingDecks.slice(0, 3).map(item => `
                  <div class="featured-deck" data-deck-id="${item.deck.id}">
                    <h3>${item.deck.name}</h3>
                    <p>${getCardCount(item.deck.id)} cards</p>
                    <div class="due-date">Due: ${formatDate(item.dueDate)}</div>
                  </div>
                `).join('')}
              </div>
            </div>
          ` : ''}
          
          <div class="section-header">
            <h2 class="section-title">Subjects</h2>
          </div>
          <div class="list">
            ${rootFolders.length > 0 ? rootFolders.map(folder => `
              <div class="list-item" data-folder-path="${folder.path}">
                <div class="list-item-content">
                  <div class="list-item-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/>
                    </svg>
                  </div>
                  <div class="list-item-text">
                    <h3>${folder.name}</h3>
                    <p>${getSubfolderCount(folder.path)} folders, ${getDeckCountInFolder(folder.path)} decks</p>
                  </div>
                </div>
                <span class="list-item-arrow">→</span>
              </div>
            `).join('') : `
              <div class="empty-state">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/>
                </svg>
                <h3>No folders yet</h3>
                <p>Add folders in Google Sheets</p>
              </div>
            `}
          </div>
        </div>
      `;
    }

    function renderFolderView() {
      const folder = state.folders.find(f => f.path === state.currentFolder);
      const subfolders = state.folders
        .filter(f => f.parentPath === state.currentFolder)
        .sort((a, b) => (a.order || 999) - (b.order || 999));
      
      // Get decks in this folder (direct only)
      const decks = state.decks.filter(d => d.folderPath === state.currentFolder);

      const parentPath = folder?.parentPath || null;

      return `
        <div class="header">
          <button class="header-back" onclick="navigateBack('${parentPath || ''}')">
            ← Back
          </button>
          <h1>${folder?.name || 'Folder'}</h1>
          <div class="header-actions">
            <button class="btn-icon" onclick="showAddDeck('${state.currentFolder}')" title="Add deck">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="2" y="4" width="20" height="16" rx="2"/>
                <line x1="12" y1="9" x2="12" y2="15"/>
                <line x1="9" y1="12" x2="15" y2="12"/>
              </svg>
            </button>
          </div>
        </div>
        <div class="container">
          ${subfolders.length > 0 ? `
            <div class="section-header">
              <h2 class="section-title">Folders</h2>
            </div>
            <div class="list">
              ${subfolders.map(f => `
                <div class="list-item" data-folder-path="${f.path}">
                  <div class="list-item-content">
                    <div class="list-item-icon">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/>
                      </svg>
                    </div>
                    <div class="list-item-text">
                      <h3>${f.name}</h3>
                      <p>${getDeckCountInFolder(f.path)} decks</p>
                    </div>
                  </div>
                  <span class="list-item-arrow">→</span>
                </div>
              `).join('')}
            </div>
          ` : ''}
          
          ${decks.length > 0 ? `
            <div class="section-header" style="margin-top: ${subfolders.length > 0 ? '24px' : '0'}">
              <h2 class="section-title">Decks</h2>
            </div>
            <div class="list">
              ${decks.map(deck => `
                <div class="list-item" data-deck-id="${deck.id}">
                  <div class="list-item-content">
                    <div class="list-item-icon">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="2" y="4" width="20" height="16" rx="2"/>
                        <line x1="2" y1="10" x2="22" y2="10"/>
                      </svg>
                    </div>
                    <div class="list-item-text">
                      <h3>${deck.name}</h3>
                      <p>${getCardCount(deck.id)} cards</p>
                    </div>
                  </div>
                  <span class="list-item-arrow">→</span>
                </div>
              `).join('')}
            </div>
          ` : ''}

          ${subfolders.length === 0 && decks.length === 0 ? `
            <div class="empty-state">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="2" y="4" width="20" height="16" rx="2"/>
              </svg>
              <h3>Empty folder</h3>
              <p>Add decks in Google Sheets</p>
            </div>
          ` : ''}
        </div>
      `;
    }

    function renderStudySetupView() {
      const deck = state.decks.find(d => d.id === state.studySession?.deckId);
      const cardCount = getCardCount(state.studySession?.deckId);

      return `
        <div class="header">
          <button class="header-back" onclick="cancelStudy()">← Back</button>
          <h1>${deck?.name || 'Study'}</h1>
          <div></div>
        </div>
        <div class="container">
          <div class="card" style="text-align: center; padding: 32px;">
            <h2 style="margin-bottom: 8px;">${deck?.name}</h2>
            <p style="color: var(--text-secondary); margin-bottom: 24px;">${cardCount} cards</p>
            
            <div class="study-options">
              <button class="toggle-btn ${state.settings.shuffle ? 'active' : ''}" data-toggle="shuffle">
                Shuffle ${state.settings.shuffle ? '✓' : ''}
              </button>
              <button class="toggle-btn active" onclick="toggleFrontSide()">
                Front: ${state.settings.reverse ? 'Definition' : 'Term'}
              </button>
            </div>
            
            <button class="btn btn-primary" onclick="startStudy()" style="width: 100%; margin-top: 16px;">
              Start Studying
            </button>
          </div>
        </div>
      `;
    }

    function renderStudyView() {
      const session = state.studySession;
      if (!session || session.cards.length === 0 || session.currentIndex >= session.cards.length) {
        return renderStudyComplete();
      }

      const card = session.cards[session.currentIndex];
      const progress = ((session.currentIndex) / session.totalCards) * 100;
      const front = state.settings.reverse ? card.definition : card.term;
      const back = state.settings.reverse ? card.term : card.definition;
      const frontImage = state.settings.reverse ? card.imageBack : card.imageFront;
      const backImage = state.settings.reverse ? card.imageFront : card.imageBack;

      return `
        <div class="header">
          <button class="header-back" onclick="cancelStudy()">← Exit</button>
          <h1>Studying</h1>
          <div></div>
        </div>
        <div class="study-container">
          <div class="study-progress">
            <div class="progress-bar">
              <div class="progress-fill" style="width: ${progress}%"></div>
            </div>
            <div class="progress-text">
              <span>${session.currentIndex + 1} / ${session.totalCards}</span>
              <span style="color: var(--success)">✓ ${session.correct}</span>
              <span style="color: var(--error)">✗ ${session.wrong}</span>
            </div>
          </div>

          <div class="flashcard-wrapper">
            <div class="flashcard" id="flashcard">
              <div class="swipe-overlay swipe-overlay-correct" id="swipe-overlay-correct"></div>
              <div class="swipe-overlay swipe-overlay-wrong" id="swipe-overlay-wrong"></div>
              <div class="flashcard-inner" id="flashcard-inner">
                <div class="flashcard-face flashcard-front">
                  <span class="flashcard-label">${state.settings.reverse ? 'Definition' : 'Term'}</span>
                  <h2>${front}</h2>
                  ${frontImage ? `<img src="${frontImage}" alt=""/>` : ''}
                </div>
                <div class="flashcard-face flashcard-back">
                  <span class="flashcard-label">${state.settings.reverse ? 'Term' : 'Definition'}</span>
                  <h2>${back}</h2>
                  ${backImage ? `<img src="${backImage}" alt=""/>` : ''}
                </div>
              </div>
            </div>
          </div>

          <div class="study-actions">
            <button class="study-btn back" onclick="goBackCard()" title="Undo" ${!session.history || session.history.length === 0 ? 'disabled' : ''}>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                <path d="M3 10h10a5 5 0 015 5v0a5 5 0 01-5 5H10"/>
                <polyline points="7 14 3 10 7 6"/>
              </svg>
            </button>
          </div>
        </div>
      `;
    }

    function renderStudyComplete() {
      const session = state.studySession;
      const hasWrongCards = session.wrongCards.length > 0;

      return `
        <div class="header">
          <button class="header-back" onclick="cancelStudy()">← Done</button>
          <h1>Complete!</h1>
          <div></div>
        </div>
        <div class="study-complete">
          <h2>Session Complete!</h2>
          <div class="study-stats">
            <div class="stat">
              <div class="stat-value correct">${session.correct}</div>
              <div class="stat-label">Correct</div>
            </div>
            <div class="stat">
              <div class="stat-value wrong">${session.wrong}</div>
              <div class="stat-label">Wrong</div>
            </div>
          </div>
          <div class="study-complete-actions">
            ${hasWrongCards ? `
              <button class="btn btn-primary" onclick="retryWrongCards()">
                Retry Wrong Cards (${session.wrongCards.length})
              </button>
            ` : ''}
            <button class="btn btn-secondary" onclick="restartDeck()">
              Study Again
            </button>
            <button class="btn btn-secondary" onclick="cancelStudy()">
              Back to Flashcards
            </button>
          </div>
        </div>
      `;
    }

    const PRIORITY_ORDER = { summative: 1, formative: 2, task: 3, low: 4 };

    function sortTodos(todos) {
      return [...todos].sort((a, b) => {
        // First by due date
        if (!a.dueDate && !b.dueDate) {
          return (PRIORITY_ORDER[a.priority] || 99) - (PRIORITY_ORDER[b.priority] || 99);
        }
        if (!a.dueDate) return 1;
        if (!b.dueDate) return -1;
        const dateDiff = new Date(a.dueDate) - new Date(b.dueDate);
        if (dateDiff !== 0) return dateDiff;
        // Same due date — sort by priority
        return (PRIORITY_ORDER[a.priority] || 99) - (PRIORITY_ORDER[b.priority] || 99);
      });
    }

    function renderTodoItem(todo, isCompleted = false) {
      const timeStr = todo.dueTime ? formatTime(todo.dueTime) : '';
      return `
        <div class="todo-item">
          <div class="todo-checkbox${isCompleted ? ' checked' : ''}" onclick="${isCompleted ? `uncompleteTodo('${todo.id}')` : `completeTodo('${todo.id}')`}"></div>
          <div class="todo-content">
            <div class="todo-title">${todo.title}</div>
            ${todo.description ? `<div class="todo-description">${todo.description}</div>` : ''}
            <div class="todo-details">
              ${todo.priority ? `<span class="priority-badge ${todo.priority}">${todo.priority}</span>` : ''}
              ${todo.dueDate ? `
                <span class="todo-detail-chip ${isOverdue(todo.dueDate) && !isCompleted ? 'overdue' : ''}">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
                  ${formatDate(todo.dueDate)}${timeStr ? ' · ' + timeStr : ''}
                </span>
              ` : ''}
              ${todo.reminders && todo.reminders.length > 0 ? `
                <span class="todo-detail-chip">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 8A6 6 0 006 8c0 7-3 9-3 9h18s-3-2-3-9"/><path d="M13.73 21a2 2 0 01-3.46 0"/></svg>
                  ${todo.reminders.length}
                </span>
              ` : ''}
            </div>
            ${todo.linkedDecks && todo.linkedDecks.length > 0 ? `
              <div class="todo-decks">
                ${todo.linkedDecks.map(deckId => {
                  const deck = state.decks.find(d => d.id === deckId);
                  return deck ? `<button class="todo-deck-link" onclick="event.stopPropagation(); openDeckFromTodo('${deckId}')">${deck.name}</button>` : '';
                }).join('')}
              </div>
            ` : ''}
          </div>
          <button class="todo-delete-btn" onclick="event.stopPropagation(); deleteTodo('${todo.id}')">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
            </svg>
          </button>
        </div>
      `;
    }

    function renderTodosView() {
      const activeTodos = sortTodos(state.todos.filter(t => !t.completed));
      const completedTodos = state.todos.filter(t => t.completed);
      const showCompleted = state.showCompleted || false;

      return `
        <div class="header">
          <h1>Tasks</h1>
          <button class="btn-icon" onclick="syncData().then(render)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M23 4v6h-6M1 20v-6h6"/>
              <path d="M3.51 9a9 9 0 0114.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0020.49 15"/>
            </svg>
          </button>
        </div>
        <div class="container">
          ${activeTodos.length > 0 ? `
            <div class="todo-list">
              ${activeTodos.map(t => renderTodoItem(t)).join('')}
            </div>
          ` : `
            <div class="empty-state">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M9 11l3 3L22 4"/>
                <path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11"/>
              </svg>
              <h3>No tasks yet</h3>
              <p>Tap + to get started</p>
            </div>
          `}

          ${completedTodos.length > 0 ? `
            <div class="completed-section">
              <div class="completed-header ${showCompleted ? 'expanded' : ''}" onclick="state.showCompleted = !state.showCompleted; render();">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="9 18 15 12 9 6"/></svg>
                <span>Completed (${completedTodos.length})</span>
              </div>
              <div class="completed-list" style="max-height: ${showCompleted ? completedTodos.length * 80 + 'px' : '0'};">
                ${completedTodos.map(t => renderTodoItem(t, true)).join('')}
              </div>
            </div>
          ` : ''}
        </div>
        <button class="fab" onclick="showAddTodo()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
            <line x1="12" y1="5" x2="12" y2="19"/>
            <line x1="5" y1="12" x2="19" y2="12"/>
          </svg>
        </button>
      `;
    }

    let selectedPriority = 'task';
    let selectedLinkedDecks = [];
    let deckPickerPath = null; // null = root

    function renderAddTodoView() {
      return `
        <div class="header">
          <button class="header-back" onclick="state.currentView = 'todos'; render();">← Cancel</button>
          <h1>New Task</h1>
          <div></div>
        </div>
        <div class="container">
          <form id="todo-form" onsubmit="saveTodo(event)">
            <div class="form-group">
              <label class="form-label">Title *</label>
              <input type="text" class="form-input" id="todo-title" required placeholder="Task name">
            </div>

            <div class="form-group">
              <label class="form-label">Description</label>
              <textarea class="form-input" id="todo-description" placeholder="Add details" rows="2"></textarea>
            </div>

            <div class="form-group">
              <label class="form-label">Priority</label>
              <div class="priority-options">
                <button type="button" class="priority-option ${selectedPriority === 'summative' ? 'selected' : ''}" data-priority="summative" onclick="selectPriority('summative')">Summative</button>
                <button type="button" class="priority-option ${selectedPriority === 'formative' ? 'selected' : ''}" data-priority="formative" onclick="selectPriority('formative')">Formative</button>
                <button type="button" class="priority-option ${selectedPriority === 'task' ? 'selected' : ''}" data-priority="task" onclick="selectPriority('task')">Task</button>
                <button type="button" class="priority-option ${selectedPriority === 'low' ? 'selected' : ''}" data-priority="low" onclick="selectPriority('low')">Low</button>
              </div>
            </div>

            <div class="form-group">
              <label class="form-label">Due Date</label>
              <input type="date" class="form-input" id="todo-due">
            </div>

            <div class="form-group">
              <label class="form-label">Time</label>
              <div class="time-picker-row">
                <div class="scroll-picker" id="hour-picker"></div>
                <span class="time-picker-separator">:</span>
                <div class="scroll-picker" id="minute-picker"></div>
              </div>
            </div>

            <div class="form-group">
              <label class="form-label">Link Decks</label>
              ${selectedLinkedDecks.length > 0 ? `
                <div class="selected-decks-chips">
                  ${selectedLinkedDecks.map(id => {
                    const d = state.decks.find(x => x.id === id);
                    return d ? `<div class="selected-deck-chip">${d.name}<button type="button" onclick="toggleLinkedDeck('${id}')">×</button></div>` : '';
                  }).join('')}
                </div>
              ` : ''}
              <div class="deck-picker" id="deck-picker">
                ${renderDeckPicker()}
              </div>
            </div>

            <div class="form-group">
              <label class="form-label">Reminders</label>
              <div id="reminders-container" class="reminder-chips"></div>
              <div style="margin-top: 12px;">
                <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                  <input type="date" class="form-input" id="reminder-date" style="flex: 1;">
                  <input type="time" class="form-input" id="reminder-time" value="09:00" style="width: 110px;">
                  <button type="button" class="btn btn-secondary" style="padding: 8px 14px;" onclick="addReminderFromInputs()">+</button>
                </div>
                <button type="button" class="btn btn-secondary" style="width: 100%; font-size: 0.8rem; padding: 8px;" onclick="autoGenerateReminders()">
                  Auto-generate (1-3-7-14 days before)
                </button>
              </div>
            </div>

            <button type="submit" class="btn btn-primary" style="width: 100%; margin-top: 24px;">
              Save Task
            </button>
          </form>
        </div>
      `;
    }

    function renderDeckPicker() {
      const currentPath = deckPickerPath;

      // Build breadcrumb
      let breadcrumb = '';
      if (currentPath) {
        const parts = [];
        let p = currentPath;
        while (p) {
          const f = state.folders.find(x => x.path === p);
          if (f) { parts.unshift(f); p = f.parentPath; } else break;
        }
        breadcrumb = `
          <div class="deck-picker-breadcrumb">
            <button onclick="navigateDeckPicker(null)">All</button>
            ${parts.map((f, i) => `
              <span>›</span>
              ${i < parts.length - 1
                ? `<button onclick="navigateDeckPicker('${f.path}')">${f.name}</button>`
                : `<span style="color:var(--text-secondary)">${f.name}</span>`
              }
            `).join('')}
          </div>
        `;
      }

      // Get subfolders
      const subfolders = state.folders
        .filter(f => currentPath ? f.parentPath === currentPath : !f.parentPath)
        .sort((a, b) => (a.order || 999) - (b.order || 999));

      // Get decks in current folder
      const decks = state.decks.filter(d => currentPath ? d.folderPath === currentPath : !d.folderPath || d.folderPath === '');

      const items = [];

      subfolders.forEach(f => {
        const deckCount = state.decks.filter(d => d.folderPath === f.path).length +
          state.folders.filter(sf => sf.parentPath === f.path).length;
        items.push(`
          <div class="deck-picker-item is-folder" onclick="navigateDeckPicker('${f.path}')">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg>
            <span class="dp-name">${f.name}</span>
            <span class="dp-meta">${deckCount}</span>
            <span class="dp-arrow">›</span>
          </div>
        `);
      });

      decks.forEach(d => {
        const checked = selectedLinkedDecks.includes(d.id);
        const cardCount = state.cards.filter(c => c.deckId === d.id).length;
        items.push(`
          <div class="deck-picker-item" onclick="toggleLinkedDeck('${d.id}')">
            <div class="dp-check ${checked ? 'checked' : ''}"></div>
            <span class="dp-name">${d.name}</span>
            <span class="dp-meta">${cardCount} cards</span>
          </div>
        `);
      });

      if (items.length === 0) {
        items.push(`<div style="padding:16px;text-align:center;color:var(--text-muted);font-size:0.8rem;">No items here</div>`);
      }

      return breadcrumb + items.join('');
    }

    function navigateDeckPicker(path) {
      deckPickerPath = path;
      const picker = document.getElementById('deck-picker');
      if (picker) {
        picker.innerHTML = renderDeckPicker();
        picker.scrollTop = 0;
      }
    }

    function toggleLinkedDeck(deckId) {
      const idx = selectedLinkedDecks.indexOf(deckId);
      if (idx >= 0) {
        selectedLinkedDecks.splice(idx, 1);
      } else {
        selectedLinkedDecks.push(deckId);
      }
      // Re-render just the deck picker + chips
      const picker = document.getElementById('deck-picker');
      if (picker) picker.innerHTML = renderDeckPicker();
      // Re-render chips
      const form = document.getElementById('todo-form');
      if (form) {
        const chipsContainer = form.querySelector('.selected-decks-chips');
        const label = form.querySelector('.form-group:has(#deck-picker) .form-label');
        const parent = document.getElementById('deck-picker').parentElement;
        let existingChips = parent.querySelector('.selected-decks-chips');
        if (existingChips) existingChips.remove();
        if (selectedLinkedDecks.length > 0) {
          const chipsHtml = `<div class="selected-decks-chips">${selectedLinkedDecks.map(id => {
            const d = state.decks.find(x => x.id === id);
            return d ? `<div class="selected-deck-chip">${d.name}<button type="button" onclick="toggleLinkedDeck('${id}')">×</button></div>` : '';
          }).join('')}</div>`;
          document.getElementById('deck-picker').insertAdjacentHTML('beforebegin', chipsHtml);
        }
      }
    }

    function selectPriority(p) {
      selectedPriority = p;
      document.querySelectorAll('.priority-option').forEach(el => {
        el.classList.toggle('selected', el.dataset.priority === p);
      });
    }

    // ============ LOOPING 24HR TIME PICKER ============
    const LOOP_COPIES = 3; // number of full sets to render for looping illusion

    function buildLoopingItems(values, displayFn) {
      let html = '';
      for (let c = 0; c < LOOP_COPIES; c++) {
        values.forEach(v => {
          const display = displayFn ? displayFn(v) : v;
          html += `<div class="scroll-picker-item" data-value="${v}" data-copy="${c}">${display}</div>`;
        });
      }
      return html;
    }

    function initTimePickers() {
      const hours = Array.from({length: 24}, (_, i) => i);
      const minutes = ['00','05','10','15','20','25','30','35','40','45','50','55'];

      const hourPicker = document.getElementById('hour-picker');
      const minutePicker = document.getElementById('minute-picker');
      if (!hourPicker || !minutePicker) return;

      // Build content
      hourPicker.innerHTML = `<div class="scroll-picker-highlight"></div>` +
        buildLoopingItems(hours, h => String(h).padStart(2, '0'));
      minutePicker.innerHTML = `<div class="scroll-picker-highlight"></div>` +
        buildLoopingItems(minutes);

      // Setup each picker
      [
        { el: hourPicker, count: 24, defaultVal: 9 },
        { el: minutePicker, count: 12, defaultVal: 0 }
      ].forEach(({ el, count, defaultVal }) => {
        const itemH = 40;
        const totalPerSet = count;

        // Scroll to middle copy's default
        setTimeout(() => {
          const middleStart = totalPerSet * Math.floor(LOOP_COPIES / 2);
          el.scrollTop = (middleStart + defaultVal) * itemH - (el.clientHeight / 2 - itemH / 2);
          updatePickerSelection(el);
        }, 30);

        el.addEventListener('scroll', () => {
          updatePickerSelection(el);
          // Loop: if near top or bottom, jump to middle copy
          const oneSetHeight = totalPerSet * itemH;
          const middleTop = oneSetHeight;
          const middleBottom = oneSetHeight * 2;
          if (el.scrollTop < itemH * 2) {
            el.scrollTop += oneSetHeight;
          } else if (el.scrollTop > middleBottom - itemH * 2) {
            el.scrollTop -= oneSetHeight;
          }
        }, { passive: true });

        // Snap on scroll end
        let scrollTimer;
        el.addEventListener('scroll', () => {
          clearTimeout(scrollTimer);
          scrollTimer = setTimeout(() => {
            snapToNearest(el, itemH);
          }, 80);
        }, { passive: true });
      });
    }

    function snapToNearest(picker, itemH) {
      const centerOffset = picker.clientHeight / 2 - itemH / 2;
      const target = Math.round((picker.scrollTop + centerOffset) / itemH) * itemH - centerOffset;
      picker.scrollTo({ top: target, behavior: 'smooth' });
    }

    function updatePickerSelection(picker) {
      const items = picker.querySelectorAll('.scroll-picker-item');
      const pickerRect = picker.getBoundingClientRect();
      const center = pickerRect.top + pickerRect.height / 2;
      let closest = null;
      let closestDist = Infinity;

      items.forEach(item => {
        const rect = item.getBoundingClientRect();
        const dist = Math.abs(rect.top + rect.height / 2 - center);
        item.classList.remove('selected');
        if (dist < closestDist) {
          closestDist = dist;
          closest = item;
        }
      });

      if (closest) closest.classList.add('selected');
    }

    function getPickerTime() {
      const getSelected = (id) => {
        const picker = document.getElementById(id);
        if (!picker) return null;
        const sel = picker.querySelector('.scroll-picker-item.selected');
        return sel ? sel.dataset.value : null;
      };

      const hour = getSelected('hour-picker') || '09';
      const minute = getSelected('minute-picker') || '00';
      return `${String(hour).padStart(2, '0')}:${minute}`;
    }

    function renderAddFolderView() {
      const parentPath = state.editingParentFolder || '';
      const parentFolder = state.folders.find(f => f.path === parentPath);
      
      return `
        <div class="header">
          <button class="header-back" onclick="cancelAddFolder()">← Cancel</button>
          <h1>Add Folder</h1>
          <div></div>
        </div>
        <div class="container">
          <form onsubmit="saveFolder(event)">
            <div class="form-group">
              <label class="form-label">Folder Name *</label>
              <input type="text" class="form-input" id="folder-name" required placeholder="e.g., Math, Science, History">
            </div>
            
            <div class="form-group">
              <label class="form-label">Parent Folder</label>
              <input type="text" class="form-input" value="${parentFolder ? parentFolder.name : 'None (root)'}" disabled>
            </div>
            
            <div class="form-group">
              <label class="form-label">Order (lower = first)</label>
              <input type="number" class="form-input" id="folder-order" value="999" min="1">
            </div>
            
            <button type="submit" class="btn btn-primary" style="width: 100%; margin-top: 24px;">
              Create Folder
            </button>
          </form>
        </div>
      `;
    }

    function renderAddDeckView() {
      const folderPath = state.editingParentFolder || '';
      const folder = state.folders.find(f => f.path === folderPath);
      
      return `
        <div class="header">
          <button class="header-back" onclick="cancelAddDeck()">← Cancel</button>
          <h1>Add Deck</h1>
          <div></div>
        </div>
        <div class="container">
          <form onsubmit="saveDeck(event)">
            <div class="form-group">
              <label class="form-label">Deck Name *</label>
              <input type="text" class="form-input" id="deck-name" required placeholder="e.g., Chapter 1 Vocabulary">
            </div>
            
            <div class="form-group">
              <label class="form-label">Folder</label>
              <input type="text" class="form-input" value="${folder ? folder.name : 'None'}" disabled>
            </div>
            
            <button type="submit" class="btn btn-primary" style="width: 100%; margin-top: 24px;">
              Create Deck
            </button>
          </form>
        </div>
      `;
    }

    function renderDeckDetailView() {
      const deck = state.decks.find(d => d.id === state.currentDeck);
      const deckCards = state.cards.filter(c => c.deckId === state.currentDeck);
      
      return `
        <div class="header">
          <button class="header-back" onclick="goBackFromDeck()">← Back</button>
          <h1>${deck?.name || 'Deck'}</h1>
          <button class="btn-icon" onclick="showAddCard()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <line x1="12" y1="5" x2="12" y2="19"/>
              <line x1="5" y1="12" x2="19" y2="12"/>
            </svg>
          </button>
        </div>
        <div class="container">
          <div style="display: flex; gap: 12px; margin-bottom: 24px;">
            <button class="btn btn-primary" style="flex: 1;" onclick="openDeck('${state.currentDeck}')">
              Study (${deckCards.length} cards)
            </button>
          </div>
          
          <div class="section-header">
            <h2 class="section-title">Cards</h2>
          </div>
          
          ${deckCards.length > 0 ? `
            <div class="list">
              ${deckCards.map(card => `
                <div class="list-item" onclick="editCard('${card.id}')">
                  <div class="list-item-content" style="flex: 1;">
                    <div class="list-item-text">
                      <h3>${card.term}</h3>
                      <p>${card.definition}</p>
                    </div>
                  </div>
                  <button class="btn-icon" onclick="event.stopPropagation(); deleteCard('${card.id}')" style="color: var(--text-muted);">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                      <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
                    </svg>
                  </button>
                </div>
              `).join('')}
            </div>
          ` : `
            <div class="empty-state">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="2" y="4" width="20" height="16" rx="2"/>
              </svg>
              <h3>No cards yet</h3>
              <p>Tap + to add your first card</p>
            </div>
          `}
        </div>
      `;
    }

    function renderAddCardView() {
      const deck = state.decks.find(d => d.id === state.currentDeck);
      
      return `
        <div class="header">
          <button class="header-back" onclick="state.currentView = 'deck-detail'; render();">← Cancel</button>
          <h1>Add Card</h1>
          <div></div>
        </div>
        <div class="container">
          <div style="background: var(--bg-tertiary); padding: 12px; border-radius: 8px; margin-bottom: 20px; font-size: 0.75rem; color: var(--text-secondary);">
            <strong>Tip:</strong> For bold/underline/italic, add the card here then format in Google Sheets.
          </div>
          <form onsubmit="saveCard(event)">
            <div class="form-group">
              <label class="form-label">Term (Front) *</label>
              <textarea class="form-input" id="card-term" required placeholder="Enter the term or question" rows="3"></textarea>
            </div>
            
            <div class="form-group">
              <label class="form-label">Definition (Back) *</label>
              <textarea class="form-input" id="card-definition" required placeholder="Enter the definition or answer" rows="3"></textarea>
            </div>
            
            <div class="form-group">
              <label class="form-label">Image - Front (optional)</label>
              <input type="file" class="form-input" id="card-image-front" accept="image/*" onchange="previewImage(this, 'preview-front')">
              <div id="preview-front" style="margin-top: 8px;"></div>
            </div>
            
            <div class="form-group">
              <label class="form-label">Image - Back (optional)</label>
              <input type="file" class="form-input" id="card-image-back" accept="image/*" onchange="previewImage(this, 'preview-back')">
              <div id="preview-back" style="margin-top: 8px;"></div>
            </div>
            
            <div style="display: flex; gap: 12px; margin-top: 24px;">
              <button type="submit" class="btn btn-primary" style="flex: 1;">
                Save Card
              </button>
              <button type="button" class="btn btn-secondary" style="flex: 1;" onclick="saveCardAndAddAnother(event)">
                Save & Add Another
              </button>
            </div>
          </form>
        </div>
      `;
    }

    function renderEditCardView() {
      const card = state.cards.find(c => c.id === state.editingCard);
      
      return `
        <div class="header">
          <button class="header-back" onclick="state.currentView = 'deck-detail'; render();">← Cancel</button>
          <h1>Edit Card</h1>
          <div></div>
        </div>
        <div class="container">
          <div style="background: var(--bg-tertiary); padding: 12px; border-radius: 8px; margin-bottom: 20px; font-size: 0.75rem; color: var(--text-secondary);">
            <strong>Note:</strong> Editing here saves plain text. For formatting, edit in Google Sheets.
          </div>
          <form onsubmit="updateCard(event)">
            <div class="form-group">
              <label class="form-label">Term (Front) *</label>
              <textarea class="form-input" id="card-term" required rows="3">${stripHtml(card?.term || '')}</textarea>
            </div>
            
            <div class="form-group">
              <label class="form-label">Definition (Back) *</label>
              <textarea class="form-input" id="card-definition" required rows="3">${stripHtml(card?.definition || '')}</textarea>
            </div>
            
            <div class="form-group">
              <label class="form-label">Image - Front (optional)</label>
              <input type="file" class="form-input" id="card-image-front" accept="image/*" onchange="previewImage(this, 'preview-front')">
              <div id="preview-front" style="margin-top: 8px;">
                ${card?.imageFront ? `<img src="${card.imageFront}" style="max-width: 100%; max-height: 150px; border-radius: 8px;">` : ''}
              </div>
              ${card?.imageFront ? `<button type="button" class="btn btn-secondary" style="margin-top: 8px; font-size: 0.75rem;" onclick="clearImage('front')">Remove Image</button>` : ''}
            </div>
            
            <div class="form-group">
              <label class="form-label">Image - Back (optional)</label>
              <input type="file" class="form-input" id="card-image-back" accept="image/*" onchange="previewImage(this, 'preview-back')">
              <div id="preview-back" style="margin-top: 8px;">
                ${card?.imageBack ? `<img src="${card.imageBack}" style="max-width: 100%; max-height: 150px; border-radius: 8px;">` : ''}
              </div>
              ${card?.imageBack ? `<button type="button" class="btn btn-secondary" style="margin-top: 8px; font-size: 0.75rem;" onclick="clearImage('back')">Remove Image</button>` : ''}
            </div>
            
            <button type="submit" class="btn btn-primary" style="width: 100%; margin-top: 24px;">
              Save Changes
            </button>
          </form>
        </div>
      `;
    }

    // ============ HELPER FUNCTIONS ============
    function getUpcomingDecks() {
      const deckDueDates = [];
      
      state.todos.forEach(todo => {
        if (!todo.linkedDecks || todo.completed || !todo.dueDate) return;
        
        todo.linkedDecks.forEach(deckId => {
          const deck = state.decks.find(d => d.id === deckId);
          if (deck) {
            deckDueDates.push({
              deck,
              dueDate: todo.dueDate,
              todoTitle: todo.title
            });
          }
        });
      });

      // Sort by due date (soonest first)
      deckDueDates.sort((a, b) => new Date(a.dueDate) - new Date(b.dueDate));
      
      // Remove duplicates (keep earliest due date)
      const seen = new Set();
      return deckDueDates.filter(item => {
        if (seen.has(item.deck.id)) return false;
        seen.add(item.deck.id);
        return true;
      });
    }

    function getCardCount(deckId) {
      return state.cards.filter(c => c.deckId === deckId).length;
    }

    function getSubfolderCount(folderPath) {
      return state.folders.filter(f => f.parentPath === folderPath).length;
    }

    function getDeckCountInFolder(folderPath) {
      return state.decks.filter(d => d.folderPath === folderPath).length;
    }

    function formatDate(dateStr) {
      if (!dateStr) return '';
      const date = new Date(dateStr);
      return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    }

    function isOverdue(dateStr) {
      return new Date(dateStr) < new Date();
    }

    // ============ NAVIGATION ============
    function navigateBack(parentPath) {
      if (parentPath) {
        state.currentFolder = parentPath;
        state.currentView = 'folder';
      } else {
        state.currentFolder = null;
        state.currentView = 'flashcards';
      }
      render();
    }

    function openFolder(path) {
      state.currentFolder = path;
      state.currentView = 'folder';
      render();
    }

    function openDeck(deckId) {
      state.studySession = {
        deckId,
        cards: [],
        currentIndex: 0,
        totalCards: 0,
        correct: 0,
        wrong: 0,
        wrongCards: []
      };
      state.currentView = 'study-setup';
      render();
    }

    function openDeckFromTodo(deckId) {
      showDeckDetail(deckId);
    }

    function cancelStudy() {
      state.studySession = null;
      state.currentView = 'flashcards';
      render();
    }

    function showAddTodo() {
      todoReminders = [];
      selectedPriority = 'task';
      selectedLinkedDecks = [];
      deckPickerPath = null;
      state.currentView = 'add-todo';
      render();
    }

    // ============ STUDY FUNCTIONS ============
    function startStudy() {
      const deckCards = state.cards.filter(c => c.deckId === state.studySession.deckId);
      const orderedCards = getWeightedCards(deckCards, state.settings.shuffle);
      
      state.studySession.cards = orderedCards;
      state.studySession.totalCards = orderedCards.length;
      state.studySession.currentIndex = 0;
      state.studySession.correct = 0;
      state.studySession.wrong = 0;
      state.studySession.wrongCards = [];
      state.currentView = 'study';
      render();
    }

    function flipCard() {
      const inner = document.getElementById('flashcard-inner');
      if (inner && !swipeState.isSwiping) {
        inner.classList.toggle('flipped');
      }
    }

    // ============ SWIPE GESTURE SYSTEM ============
    const swipeState = {
      startX: 0,
      startY: 0,
      currentX: 0,
      isDragging: false,
      isSwiping: false,
      isAnimating: false,
      threshold: 100,
      maxRotation: 15
    };

    function initSwipeHandlers() {
      const flashcard = document.getElementById('flashcard');
      if (!flashcard) return;

      // Pointer events for unified touch/mouse handling
      flashcard.addEventListener('pointerdown', onSwipeStart, { passive: false });
      
      // Remove previous document-level listeners before re-adding
      document.removeEventListener('pointermove', onSwipeMove);
      document.removeEventListener('pointerup', onSwipeEnd);
      document.removeEventListener('pointercancel', onSwipeEnd);
      document.addEventListener('pointermove', onSwipeMove, { passive: false });
      document.addEventListener('pointerup', onSwipeEnd);
      document.addEventListener('pointercancel', onSwipeEnd);
    }

    function onSwipeStart(e) {
      if (swipeState.isAnimating) return;
      swipeState.startX = e.clientX;
      swipeState.startY = e.clientY;
      swipeState.currentX = 0;
      swipeState.isDragging = true;
      swipeState.isSwiping = false;

      const flashcard = document.getElementById('flashcard');
      if (flashcard) {
        flashcard.classList.add('swiping');
        flashcard.setPointerCapture(e.pointerId);
      }
    }

    function onSwipeMove(e) {
      if (!swipeState.isDragging || swipeState.isAnimating) return;
      
      const dx = e.clientX - swipeState.startX;
      const dy = e.clientY - swipeState.startY;

      // If vertical movement dominates early on, don't swipe (allow flip)
      if (!swipeState.isSwiping && Math.abs(dy) > Math.abs(dx) && Math.abs(dx) < 10) {
        return;
      }

      // Once horizontal movement starts, commit to swiping
      if (Math.abs(dx) > 10) {
        swipeState.isSwiping = true;
      }

      if (!swipeState.isSwiping) return;

      e.preventDefault();
      swipeState.currentX = dx;

      const flashcard = document.getElementById('flashcard');
      const correctOverlay = document.getElementById('swipe-overlay-correct');
      const wrongOverlay = document.getElementById('swipe-overlay-wrong');

      if (!flashcard) return;

      // Calculate rotation based on drag distance
      const rotation = (dx / window.innerWidth) * swipeState.maxRotation;
      const opacity = Math.min(Math.abs(dx) / swipeState.threshold, 1);

      flashcard.style.transform = `translateX(${dx}px) rotate(${rotation}deg)`;

      // Show overlays based on direction
      if (correctOverlay && wrongOverlay) {
        if (dx > 0) {
          correctOverlay.style.opacity = opacity * 0.9;
          wrongOverlay.style.opacity = 0;
        } else if (dx < 0) {
          wrongOverlay.style.opacity = opacity * 0.9;
          correctOverlay.style.opacity = 0;
        } else {
          correctOverlay.style.opacity = 0;
          wrongOverlay.style.opacity = 0;
        }
      }
    }

    function onSwipeEnd(e) {
      if (!swipeState.isDragging) return;
      swipeState.isDragging = false;

      const flashcard = document.getElementById('flashcard');
      if (!flashcard) return;

      const dx = swipeState.currentX;

      if (swipeState.isSwiping && Math.abs(dx) >= swipeState.threshold) {
        // Swipe completed — animate off screen
        const isCorrect = dx > 0;
        animateCardOut(isCorrect);
      } else if (swipeState.isSwiping) {
        // Snap back
        snapCardBack(flashcard);
      } else {
        // It was a tap — flip the card
        flipCard();
        flashcard.classList.remove('swiping');
      }

      swipeState.isSwiping = false;
    }

    function animateCardOut(isCorrect) {
      swipeState.isAnimating = true;
      const flashcard = document.getElementById('flashcard');
      if (!flashcard) return;

      const direction = isCorrect ? 1 : -1;
      const flyX = direction * (window.innerWidth + 200);
      const flyRotation = direction * 30;

      flashcard.classList.remove('swiping');
      flashcard.classList.add('animate-out');
      flashcard.style.transform = `translateX(${flyX}px) rotate(${flyRotation}deg)`;
      flashcard.style.opacity = '0';

      setTimeout(() => {
        swipeState.isAnimating = false;
        markCardWithAnimation(isCorrect);
      }, 250);
    }

    function snapCardBack(flashcard) {
      flashcard.classList.remove('swiping');
      flashcard.style.transition = 'transform 0.3s cubic-bezier(0.2, 0, 0.2, 1)';
      flashcard.style.transform = 'translateX(0) rotate(0deg)';

      const correctOverlay = document.getElementById('swipe-overlay-correct');
      const wrongOverlay = document.getElementById('swipe-overlay-wrong');
      if (correctOverlay) correctOverlay.style.opacity = 0;
      if (wrongOverlay) wrongOverlay.style.opacity = 0;

      setTimeout(() => {
        flashcard.style.transition = '';
      }, 300);
    }

    function animateButtonPress(isCorrect) {
      if (swipeState.isAnimating) return;
      swipeState.isAnimating = true;
      
      const flashcard = document.getElementById('flashcard');
      const overlay = document.getElementById(isCorrect ? 'swipe-overlay-correct' : 'swipe-overlay-wrong');
      if (!flashcard) return;

      // Flash the overlay briefly
      if (overlay) overlay.style.opacity = '0.9';

      const direction = isCorrect ? 1 : -1;
      const flyX = direction * (window.innerWidth + 200);
      const flyRotation = direction * 25;

      requestAnimationFrame(() => {
        flashcard.classList.add('animate-out');
        flashcard.style.transform = `translateX(${flyX}px) rotate(${flyRotation}deg)`;
        flashcard.style.opacity = '0';
      });

      setTimeout(() => {
        swipeState.isAnimating = false;
        markCardWithAnimation(isCorrect);
      }, 250);
    }

    function markCardWithAnimation(correct) {
      const session = state.studySession;
      const card = session.cards[session.currentIndex];

      if (!session.history) session.history = [];
      session.history.push({
        index: session.currentIndex,
        correct: correct,
        prevWrongCount: card.wrongCount || 0
      });

      if (correct) {
        session.correct++;
        card.wrongCount = 0;
      } else {
        session.wrong++;
        session.wrongCards.push(card);
        card.wrongCount = (card.wrongCount || 0) + 1;
      }

      apiCall('updateCardStats', {
        id: card.id,
        wrongCount: card.wrongCount,
        lastStudied: new Date().toISOString()
      }).catch(console.error);

      session.currentIndex++;
      
      if (session.currentIndex >= session.cards.length) {
        saveToLocal();
      }
      
      render();

      // Animate the new card entering
      requestAnimationFrame(() => {
        const newCard = document.getElementById('flashcard');
        if (newCard) {
          newCard.classList.add('animate-enter');
          newCard.addEventListener('animationend', () => {
            newCard.classList.remove('animate-enter');
          }, { once: true });
        }
      });
    }
    async function markCard(correct) {
      // Use animation when called from buttons
      animateButtonPress(correct);
    }

    function goBackCard() {
      const session = state.studySession;
      if (!session.history || session.history.length === 0) return;

      const lastAction = session.history.pop();
      const card = session.cards[lastAction.index];

      // Undo the score change
      if (lastAction.correct) {
        session.correct--;
      } else {
        session.wrong--;
        // Remove card from wrongCards
        const idx = session.wrongCards.findIndex(c => c.id === card.id);
        if (idx !== -1) session.wrongCards.splice(idx, 1);
      }

      // Restore wrong count
      card.wrongCount = lastAction.prevWrongCount;

      // Go back to previous card
      session.currentIndex = lastAction.index;

      render();
    }

    function retryWrongCards() {
      const session = state.studySession;
      session.cards = state.settings.shuffle 
        ? [...session.wrongCards].sort(() => Math.random() - 0.5)
        : [...session.wrongCards];
      session.totalCards = session.cards.length;
      session.currentIndex = 0;
      session.correct = 0;
      session.wrong = 0;
      session.wrongCards = [];
      state.currentView = 'study';
      render();
    }

    function restartDeck() {
      startStudy();
    }

    // ============ TODO FUNCTIONS ============
    let todoReminders = [];

    function autoGenerateReminders() {
      const dueInput = document.getElementById('todo-due');
      const timeInput = document.getElementById('reminder-time');
      if (!dueInput.value) {
        alert('Please set a due date first');
        return;
      }

      const dueDate = new Date(dueInput.value);
      const time = timeInput.value || '09:00';
      const now = new Date();
      
      // Generate reminders for 1, 3, 7, 14 days before due date
      const daysBefore = [1, 3, 7, 14];
      const newReminders = [];
      
      daysBefore.forEach(days => {
        const reminderDate = new Date(dueDate);
        reminderDate.setDate(reminderDate.getDate() - days);
        const reminderDateTime = `${reminderDate.toISOString().split('T')[0]}T${time}`;
        
        // Only add if in the future
        if (new Date(reminderDateTime) > now) {
          newReminders.push(reminderDateTime);
        }
      });
      
      // If all reminders are in past, add one for due date itself
      if (newReminders.length === 0) {
        const dueDateReminder = `${dueInput.value}T${time}`;
        if (new Date(dueDateReminder) > now) {
          newReminders.push(dueDateReminder);
        } else {
          // Add reminder for 1 hour from now
          const soonDate = new Date(now.getTime() + 60 * 60 * 1000);
          const soonReminder = soonDate.toISOString().slice(0, 16);
          newReminders.push(soonReminder);
        }
      }
      
      todoReminders = newReminders;
      renderReminders();
    }

    function addManualReminder() {
      const date = prompt('Enter reminder date (YYYY-MM-DD):');
      if (date && /^\d{4}-\d{2}-\d{2}$/.test(date)) {
        const timeInput = document.getElementById('todo-time');
        const defaultTime = timeInput ? timeInput.value : '09:00';
        const time = prompt('Enter reminder time (HH:MM, 24-hour format):', defaultTime);
        if (time && /^\d{2}:\d{2}$/.test(time)) {
          todoReminders.push(`${date}T${time}`);
          renderReminders();
        }
      }
    }

    function addReminderFromInputs() {
      const dateInput = document.getElementById('reminder-date');
      const timeInput = document.getElementById('reminder-time');
      
      if (!dateInput.value) {
        alert('Please select a date');
        return;
      }
      
      const datetime = `${dateInput.value}T${timeInput.value || '09:00'}`;
      
      if (new Date(datetime) <= new Date()) {
        alert('Reminder must be in the future');
        return;
      }
      
      todoReminders.push(datetime);
      renderReminders();
      dateInput.value = '';
    }

    function removeReminder(index) {
      todoReminders.splice(index, 1);
      renderReminders();
    }

    function renderReminders() {
      const container = document.getElementById('reminders-container');
      container.innerHTML = todoReminders.map((datetime, i) => {
        const [date, time] = datetime.includes('T') ? datetime.split('T') : [datetime, '09:00'];
        const timeStr = time ? ` ${formatTime(time)}` : '';
        return `
          <div class="reminder-chip">
            ${formatDate(date)}${timeStr}
            <button type="button" onclick="editReminderTime(${i})" style="color: var(--accent); margin-left: 4px;">✎</button>
            <button type="button" onclick="removeReminder(${i})">×</button>
          </div>
        `;
      }).join('');
    }

    function editReminderTime(index) {
      const datetime = todoReminders[index];
      const [date, currentTime] = datetime.includes('T') ? datetime.split('T') : [datetime, '09:00'];
      const newTime = prompt('Enter new time (HH:MM, 24-hour format):', currentTime || '09:00');
      if (newTime && /^\d{2}:\d{2}$/.test(newTime)) {
        todoReminders[index] = `${date}T${newTime}`;
        renderReminders();
      }
    }

    function formatTime(time) {
      if (!time) return '';
      return time; // Already in HH:MM 24hr format
    }

    async function saveTodo(event) {
      event.preventDefault();
      
      const title = document.getElementById('todo-title').value;
      const description = document.getElementById('todo-description')?.value?.trim() || '';
      const dueDate = document.getElementById('todo-due').value;
      const dueTime = dueDate ? getPickerTime() : '';
      const linkedDecks = [...selectedLinkedDecks];

      const todo = {
        id: 'todo_' + Date.now(),
        title,
        description,
        dueDate,
        dueTime,
        priority: selectedPriority,
        reminders: [...todoReminders],
        linkedDecks,
        completed: false
      };

      state.todos.push(todo);
      saveToLocal();

      // Sync to server
      try {
        await apiCall('addTodo', {
          id: todo.id,
          title: todo.title,
          description: todo.description,
          dueDate: todo.dueDate,
          dueTime: todo.dueTime,
          priority: todo.priority,
          reminders: JSON.stringify(todo.reminders),
          linkedDecks: JSON.stringify(todo.linkedDecks)
        });
      } catch (error) {
        console.error('Failed to sync todo:', error);
      }

      todoReminders = [];
      selectedPriority = 'task';
      scheduleReminders();
      state.currentView = 'todos';
      render();
    }

    async function completeTodo(id) {
      const todo = state.todos.find(t => t.id === id);
      if (todo) {
        todo.completed = true;
        todo.completedAt = new Date().toISOString();
        saveToLocal();
        render();

        try {
          await apiCall('completeTodo', { id });
        } catch (error) {
          console.error('Failed to sync todo completion:', error);
        }
      }
    }

    async function uncompleteTodo(id) {
      const todo = state.todos.find(t => t.id === id);
      if (todo) {
        todo.completed = false;
        delete todo.completedAt;
        saveToLocal();
        render();

        try {
          await apiCall('uncompleteTodo', { id });
        } catch (error) {
          console.error('Failed to sync todo uncompletion:', error);
        }
      }
    }

    async function deleteTodo(id) {
      if (!confirm('Delete this todo?')) return;
      
      state.todos = state.todos.filter(t => t.id !== id);
      saveToLocal();
      render();

      try {
        await apiCall('deleteTodo', { id });
      } catch (error) {
        console.error('Failed to sync todo deletion:', error);
      }
    }

    // ============ FOLDER FUNCTIONS ============
    function showAddFolder(parentPath = '') {
      state.editingParentFolder = parentPath;
      state.currentView = 'add-folder';
      render();
    }

    function cancelAddFolder() {
      if (state.editingParentFolder) {
        state.currentView = 'folder';
      } else {
        state.currentView = 'flashcards';
      }
      state.editingParentFolder = null;
      render();
    }

    async function saveFolder(event) {
      event.preventDefault();
      
      const name = document.getElementById('folder-name').value.trim();
      const order = parseInt(document.getElementById('folder-order').value) || 999;
      const parentPath = state.editingParentFolder || '';
      
      // Generate path from name (lowercase, no spaces)
      const pathName = name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
      const path = parentPath ? `${parentPath}/${pathName}` : pathName;
      
      const folder = {
        path,
        name,
        parentPath,
        order
      };
      
      // Add locally
      state.folders.push(folder);
      saveToLocal();
      
      // Sync to server
      try {
        await apiCall('addFolder', {
          path: folder.path,
          name: folder.name,
          parentPath: folder.parentPath,
          order: folder.order
        });
      } catch (error) {
        console.error('Failed to sync folder:', error);
      }
      
      if (parentPath) {
        state.currentFolder = parentPath;
        state.currentView = 'folder';
      } else {
        state.currentView = 'flashcards';
      }
      state.editingParentFolder = null;
      render();
    }

    // ============ DECK FUNCTIONS ============
    function showAddDeck(folderPath = '') {
      state.editingParentFolder = folderPath;
      state.currentView = 'add-deck';
      render();
    }

    function cancelAddDeck() {
      if (state.editingParentFolder) {
        state.currentView = 'folder';
      } else {
        state.currentView = 'flashcards';
      }
      state.editingParentFolder = null;
      render();
    }

    async function saveDeck(event) {
      event.preventDefault();
      
      const name = document.getElementById('deck-name').value.trim();
      const folderPath = state.editingParentFolder || '';
      
      const deck = {
        id: 'deck_' + Date.now(),
        name,
        folderPath
      };
      
      // Add locally
      state.decks.push(deck);
      saveToLocal();
      
      // Sync to server
      try {
        await apiCall('addDeck', {
          id: deck.id,
          name: deck.name,
          folderPath: deck.folderPath
        });
      } catch (error) {
        console.error('Failed to sync deck:', error);
      }
      
      // Go to deck detail to add cards
      state.currentDeck = deck.id;
      state.currentView = 'deck-detail';
      state.editingParentFolder = null;
      render();
    }

    function showDeckDetail(deckId) {
      state.currentDeck = deckId;
      state.currentView = 'deck-detail';
      render();
    }

    function goBackFromDeck() {
      const deck = state.decks.find(d => d.id === state.currentDeck);
      if (deck && deck.folderPath) {
        state.currentFolder = deck.folderPath;
        state.currentView = 'folder';
      } else {
        state.currentView = 'flashcards';
      }
      state.currentDeck = null;
      render();
    }

    // ============ CARD FUNCTIONS ============
    function showAddCard() {
      state.currentView = 'add-card';
      render();
    }

    function editCard(cardId) {
      state.editingCard = cardId;
      state.currentView = 'edit-card';
      render();
    }

    let clearImageFront = false;
    let clearImageBack = false;

    function clearImage(side) {
      if (side === 'front') {
        clearImageFront = true;
        document.getElementById('preview-front').innerHTML = '<p style="color: var(--text-muted); font-size: 0.875rem;">Image will be removed</p>';
      } else {
        clearImageBack = true;
        document.getElementById('preview-back').innerHTML = '<p style="color: var(--text-muted); font-size: 0.875rem;">Image will be removed</p>';
      }
    }

    function previewImage(input, previewId) {
      const preview = document.getElementById(previewId);
      if (input.files && input.files[0]) {
        const reader = new FileReader();
        reader.onload = function(e) {
          preview.innerHTML = `<img src="${e.target.result}" style="max-width: 100%; max-height: 150px; border-radius: 8px;">`;
        };
        reader.readAsDataURL(input.files[0]);
      }
    }

    async function getBase64FromInput(inputId) {
      const input = document.getElementById(inputId);
      if (!input.files || !input.files[0]) return null;
      
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target.result);
        reader.readAsDataURL(input.files[0]);
      });
    }

    async function saveCard(event) {
      event.preventDefault();
      
      const term = document.getElementById('card-term').value.trim();
      const definition = document.getElementById('card-definition').value.trim();
      const imageFront = await getBase64FromInput('card-image-front');
      const imageBack = await getBase64FromInput('card-image-back');
      
      const card = {
        id: 'card_' + Date.now(),
        deckId: state.currentDeck,
        term,
        definition,
        imageFront: imageFront || '',
        imageBack: imageBack || '',
        wrongCount: 0,
        lastStudied: ''
      };
      
      // Add locally
      state.cards.push(card);
      saveToLocal();
      
      // Sync to server
      try {
        await apiCall('addCard', {
          id: card.id,
          deckId: card.deckId,
          term: card.term,
          definition: card.definition,
          imageFront: card.imageFront,
          imageBack: card.imageBack
        });
      } catch (error) {
        console.error('Failed to sync card:', error);
      }
      
      state.currentView = 'deck-detail';
      render();
    }

    async function saveCardAndAddAnother(event) {
      event.preventDefault();
      
      const term = document.getElementById('card-term').value.trim();
      const definition = document.getElementById('card-definition').value.trim();
      const imageFront = await getBase64FromInput('card-image-front');
      const imageBack = await getBase64FromInput('card-image-back');
      
      const card = {
        id: 'card_' + Date.now(),
        deckId: state.currentDeck,
        term,
        definition,
        imageFront: imageFront || '',
        imageBack: imageBack || '',
        wrongCount: 0,
        lastStudied: ''
      };
      
      // Add locally
      state.cards.push(card);
      saveToLocal();
      
      // Sync to server
      try {
        await apiCall('addCard', {
          id: card.id,
          deckId: card.deckId,
          term: card.term,
          definition: card.definition,
          imageFront: card.imageFront,
          imageBack: card.imageBack
        });
      } catch (error) {
        console.error('Failed to sync card:', error);
      }
      
      // Clear form and stay on add card view
      document.getElementById('card-term').value = '';
      document.getElementById('card-definition').value = '';
      document.getElementById('card-image-front').value = '';
      document.getElementById('card-image-back').value = '';
      document.getElementById('preview-front').innerHTML = '';
      document.getElementById('preview-back').innerHTML = '';
      
      // Focus on term input
      document.getElementById('card-term').focus();
    }

    async function updateCard(event) {
      event.preventDefault();
      
      const card = state.cards.find(c => c.id === state.editingCard);
      if (!card) return;
      
      const term = document.getElementById('card-term').value.trim();
      const definition = document.getElementById('card-definition').value.trim();
      const newImageFront = await getBase64FromInput('card-image-front');
      const newImageBack = await getBase64FromInput('card-image-back');
      
      // Update locally
      card.term = term;
      card.definition = definition;
      if (newImageFront) card.imageFront = newImageFront;
      if (newImageBack) card.imageBack = newImageBack;
      if (clearImageFront) card.imageFront = '';
      if (clearImageBack) card.imageBack = '';
      
      saveToLocal();
      
      // Sync to server
      try {
        await apiCall('updateCard', {
          id: card.id,
          term: card.term,
          definition: card.definition,
          imageFront: card.imageFront,
          imageBack: card.imageBack
        });
      } catch (error) {
        console.error('Failed to sync card update:', error);
      }
      
      clearImageFront = false;
      clearImageBack = false;
      state.editingCard = null;
      state.currentView = 'deck-detail';
      render();
    }

    async function deleteCard(id) {
      if (!confirm('Delete this card?')) return;
      
      state.cards = state.cards.filter(c => c.id !== id);
      saveToLocal();
      render();
      
      try {
        await apiCall('deleteCard', { id });
      } catch (error) {
        console.error('Failed to sync card deletion:', error);
      }
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function stripHtml(html) {
      const div = document.createElement('div');
      div.innerHTML = html || '';
      return div.textContent || div.innerText || '';
    }

    // ============ EVENT LISTENERS ============
    function attachEventListeners() {
      // Folder clicks
      document.querySelectorAll('[data-folder-path]').forEach(el => {
        el.addEventListener('click', () => openFolder(el.dataset.folderPath));
      });

      // Deck clicks
      document.querySelectorAll('[data-deck-id]').forEach(el => {
        el.addEventListener('click', () => showDeckDetail(el.dataset.deckId));
      });

      // Toggle buttons
      document.querySelectorAll('[data-toggle]').forEach(el => {
        el.addEventListener('click', () => {
          const setting = el.dataset.toggle;
          state.settings[setting] = !state.settings[setting];
          saveToLocal();
          render();
        });
      });

      // Flashcard swipe/tap handling
      if (document.getElementById('flashcard')) {
        initSwipeHandlers();
      }
    }

    function toggleFrontSide() {
      state.settings.reverse = !state.settings.reverse;
      saveToLocal();
      render();
    }

    // KEYBOARD CONTROLS
    let keyHoldTimer = null;

    document.addEventListener('keydown', (e) => {
      if (state.currentView !== 'study') return;
      if (e.repeat) return;

      switch (e.key) {
        case 'ArrowUp':
        case 'ArrowDown':
          e.preventDefault();
          flipCard();
          break;
        case 'ArrowRight':
          e.preventDefault();
          if (!swipeState.isAnimating) markCard(true);
          break;
        case 'ArrowLeft':
          e.preventDefault();
          // Start timer for long press
          keyHoldTimer = setTimeout(() => {
            // Go back (if not at first card)
            if (state.studySession.currentIndex > 0) {
              state.studySession.currentIndex--;
              render();
            }
            keyHoldTimer = null;
          }, 1000);
          break;
      }
    });

    document.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowLeft' && keyHoldTimer) {
        clearTimeout(keyHoldTimer);
        keyHoldTimer = null;
        if (!swipeState.isAnimating) markCard(false);
      }
    });

    // Navigation
    document.querySelectorAll('.nav-item').forEach(item => {
      item.addEventListener('click', () => {
        const view = item.dataset.view;
        state.currentView = view;
        state.currentFolder = null;
        state.studySession = null;
        
        document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
        item.classList.add('active');
        
        render();
      });
    });

    // ============ NAVIGATION HISTORY & EDGE SWIPE ============
    const navHistory = [];
    
    function pushNavState() {
      navHistory.push({
        view: state.currentView,
        folder: state.currentFolder,
        deck: state.currentDeck,
        editingCard: state.editingCard,
        editingParentFolder: state.editingParentFolder,
        studySession: state.studySession ? { ...state.studySession } : null
      });
    }

    function canGoBack() {
      // Don't allow edge swipe during study
      if (state.currentView === 'study') return false;
      // These views have a back destination
      const backableViews = ['folder', 'deck-detail', 'add-card', 'edit-card', 'add-todo', 'add-folder', 'add-deck', 'study-setup', 'study-complete'];
      // Also allow going back from study-setup
      return backableViews.includes(state.currentView) || navHistory.length > 0;
    }

    function performBack() {
      if (!canGoBack()) return;
      
      switch (state.currentView) {
        case 'folder': {
          const folder = state.folders.find(f => f.path === state.currentFolder);
          const parentPath = folder?.parentPath || null;
          navigateBack(parentPath || '');
          break;
        }
        case 'deck-detail':
          goBackFromDeck();
          break;
        case 'add-card':
        case 'edit-card':
          state.editingCard = null;
          state.currentView = 'deck-detail';
          render();
          break;
        case 'add-todo':
          state.currentView = 'todos';
          render();
          break;
        case 'add-folder':
          cancelAddFolder();
          break;
        case 'add-deck':
          cancelAddDeck();
          break;
        case 'study-setup':
          cancelStudy();
          break;
        default:
          // Try nav history
          if (navHistory.length > 0) {
            const prev = navHistory.pop();
            state.currentView = prev.view;
            state.currentFolder = prev.folder;
            state.currentDeck = prev.deck;
            state.editingCard = prev.editingCard;
            state.editingParentFolder = prev.editingParentFolder;
            render();
          }
          break;
      }
    }

    // Edge swipe detection
    const edgeSwipe = {
      startX: 0,
      startY: 0,
      currentX: 0,
      active: false,
      edgeZone: 25,
      threshold: 80
    };

    document.addEventListener('touchstart', (e) => {
      const touch = e.touches[0];
      if (touch.clientX <= edgeSwipe.edgeZone && canGoBack()) {
        edgeSwipe.startX = touch.clientX;
        edgeSwipe.startY = touch.clientY;
        edgeSwipe.active = true;
        edgeSwipe.currentX = 0;
      }
    }, { passive: true });

    document.addEventListener('touchmove', (e) => {
      if (!edgeSwipe.active) return;
      
      const touch = e.touches[0];
      const dx = touch.clientX - edgeSwipe.startX;
      const dy = Math.abs(touch.clientY - edgeSwipe.startY);
      
      // Cancel if vertical movement is too large
      if (dy > 50 && dx < 30) {
        edgeSwipe.active = false;
        const arrow = document.getElementById('edge-swipe-arrow');
        if (arrow) { arrow.style.opacity = '0'; arrow.style.left = '-30px'; }
        return;
      }

      if (dx > 10) {
        edgeSwipe.currentX = dx;
        const arrow = document.getElementById('edge-swipe-arrow');
        if (arrow) {
          const progress = Math.min(dx / edgeSwipe.threshold, 1);
          arrow.style.opacity = String(progress);
          arrow.style.left = Math.min(dx - 15, 20) + 'px';
          arrow.style.background = progress >= 1 ? 'var(--accent)' : 'var(--bg-tertiary)';
        }
      }
    }, { passive: true });

    document.addEventListener('touchend', () => {
      if (!edgeSwipe.active) return;
      edgeSwipe.active = false;

      const arrow = document.getElementById('edge-swipe-arrow');
      if (arrow) {
        arrow.style.opacity = '0';
        arrow.style.left = '-30px';
      }

      if (edgeSwipe.currentX >= edgeSwipe.threshold) {
        performBack();
        // Add slide-in animation to new view
        requestAnimationFrame(() => {
          const app = document.getElementById('app');
          if (app) {
            app.classList.add('page-transition');
            app.addEventListener('animationend', () => app.classList.remove('page-transition'), { once: true });
          }
        });
      }
    }, { passive: true });

    // ============ INITIALIZATION ============
    async function init() {
      // Load from local storage first (for offline)
      const hasLocal = loadFromLocal();
      
      if (hasLocal) {
        document.getElementById('loading-screen').classList.add('hidden');
        render();
      }

      // Request notification permission
      await requestNotificationPermission();

      // Sync from server
      const synced = await syncData();
      
      if (!hasLocal && !synced) {
        document.getElementById('app').innerHTML = `
          <div class="empty-state" style="padding-top: 100px;">
            <h3>Connection Error</h3>
            <p>Could not connect to Google Sheets.</p>
            <p style="margin-top: 16px;">Check your Apps Script URL in the code.</p>
            <button class="btn btn-primary" style="margin-top: 24px;" onclick="location.reload()">
              Retry
            </button>
          </div>
        `;
        return;
      }

      render();
      scheduleReminders();

      // Register service worker
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('sw.js').catch(console.error);
      }
    }

    init();
  </script>
</body>
</html>
